//! Mob definitions using the entity_macros system
//!
//! This file consolidates:
//! - MobSpec struct definition
//! - MobId enum
//! - All mob spec constants
//! - The spec() method on MobId

use std::ops::RangeInclusive;
use std::collections::HashMap;

use rand::Rng;

use crate::item::ItemId;
use crate::loot::LootTable;
use crate::registry::{RegistryDefaults, SpawnFromSpec};
use crate::stats::{StatInstance, StatSheet, StatType};

use super::definition::Mob;

// MobQuality is kept separate since it's a simple enum not generated by macro
pub use super::enums::MobQuality;

entity_macros::define_entity! {
    spec MobSpec {
        pub name: String,
        pub max_health: RangeInclusive<i32>,
        pub attack: RangeInclusive<i32>,
        pub defense: RangeInclusive<i32>,
        pub dropped_gold: RangeInclusive<i32>,
        pub dropped_xp: RangeInclusive<i32>,
        pub quality: MobQuality,
        pub loot: LootTable,
    }

    id MobId;

    variants {
        Slime {
            name: String::from("Slime"),
            quality: MobQuality::Normal,
            max_health: 15..=22,
            attack: 2..=4,
            defense: 1..=3,
            dropped_gold: 1..=3,
            dropped_xp: 5..=9,
            loot: LootTable::new()
                .with(ItemId::SlimeGel, 3, 4, 1..=4)
                .with(ItemId::GoldRing, 1, 100, 1..=1),
        }
        Cow {
            name: String::from("Cow"),
            quality: MobQuality::Normal,
            max_health: 20..=25,
            attack: 1..=4,
            defense: 0..=2,
            dropped_gold: 1..=3,
            dropped_xp: 5..=9,
            loot: LootTable::new()
                .with(ItemId::Cowhide, 3, 4, 1..=3)
                .with(ItemId::GoldRing, 1, 1000, 1..=1),
        }
        Goblin {
            name: String::from("Goblin"),
            quality: MobQuality::Normal,
            max_health: 33..=41,
            attack: 10..=15,
            defense: 5..=10,
            dropped_gold: 10..=19,
            dropped_xp: 13..=20,
            loot: LootTable::new()
                .with(ItemId::Sword, 1, 15, 1..=1)
                .with(ItemId::BasicShield, 1, 15, 1..=1)
                .with(ItemId::GoldRing, 1, 100, 1..=1),
        }
        Dragon {
            name: String::from("Dragon"),
            quality: MobQuality::Boss,
            max_health: 500..=700,
            attack: 50..=70,
            defense: 30..=50,
            dropped_gold: 250..=350,
            dropped_xp: 500..=750,
            loot: LootTable::new()
                .with(ItemId::GoldRing, 1, 100, 1..=1)
                .with(ItemId::QualityUpgradeStone, 1, 1, 1..=1),
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Spawn Implementation
// ─────────────────────────────────────────────────────────────────────────────

impl SpawnFromSpec<MobId> for MobSpec {
    type Output = Mob;

    fn spawn_from_spec(id: MobId, spec: &Self) -> Self::Output {
        spec.spawn(id)
    }
}

impl MobSpec {
    /// Spawn a Mob from this spec with the given MobId. Internal use only.
    fn spawn(&self, id: MobId) -> Mob {
        let mut rng = rand::thread_rng();
        let hp_min = self.max_health.start();
        let hp_max = self.max_health.end();
        let hp_median = (hp_min + hp_max) as f32 / 2.0;
        let attack = rng.gen_range(*self.attack.start()..=*self.attack.end());
        let defense = rng.gen_range(*self.defense.start()..=*self.defense.end());
        let base_gold = rng.gen_range(*self.dropped_gold.start()..=*self.dropped_gold.end());
        let max_hp = rng.gen_range(*self.max_health.start()..=*self.max_health.end());
        let hp = max_hp as f32;

        let excess_ratio = if hp > hp_median {
            (hp - hp_median) / (*hp_max as f32 - hp_median)
        } else {
            0.0
        };
        let base_xp = rng.gen_range(*self.dropped_xp.start()..=*self.dropped_xp.end());
        let bonus_multiplier = 1.0 + excess_ratio * 0.5;
        let dropped_xp = (base_xp as f32 * bonus_multiplier).round() as i32;
        let gold = (base_gold as f32 * bonus_multiplier).round() as i32;

        Mob {
            mob_id: id,
            name: self.name.clone(),
            quality: self.quality.clone(),
            gold,
            stats: {
                let stats: HashMap<StatType, StatInstance> = HashMap::new();
                let mut sheet = StatSheet { stats };
                sheet.insert(StatType::Attack.instance(attack));
                sheet.insert(StatType::Defense.instance(defense));
                sheet.insert(StatType::Health.instance(max_hp));
                sheet
            },
            loot_table: self.loot.clone(),
            dropped_xp,
            death_processed: false,
        }
    }

    /// Create a scaled copy of this spec with stats multiplied by the given factor.
    /// Useful for dungeon scaling, elite variants, etc.
    pub fn with_multiplier(&self, multiplier: f32) -> MobSpec {
        let scale_range = |r: &RangeInclusive<i32>| {
            let start = (*r.start() as f32 * multiplier).round() as i32;
            let end = (*r.end() as f32 * multiplier).round() as i32;
            start..=end
        };

        MobSpec {
            name: self.name.clone(),
            max_health: scale_range(&self.max_health),
            attack: scale_range(&self.attack),
            defense: scale_range(&self.defense),
            dropped_gold: scale_range(&self.dropped_gold),
            dropped_xp: scale_range(&self.dropped_xp),
            quality: self.quality.clone(),
            loot: self.loot.clone(),
        }
    }

    /// Create a copy with a new name (e.g., for "Elite Slime").
    pub fn with_name(&self, name: impl Into<String>) -> MobSpec {
        MobSpec {
            name: name.into(),
            max_health: self.max_health.clone(),
            attack: self.attack.clone(),
            defense: self.defense.clone(),
            dropped_gold: self.dropped_gold.clone(),
            dropped_xp: self.dropped_xp.clone(),
            quality: self.quality.clone(),
            loot: self.loot.clone(),
        }
    }

    /// Create a copy with a different quality.
    pub fn with_quality(&self, quality: MobQuality) -> MobSpec {
        MobSpec {
            name: self.name.clone(),
            max_health: self.max_health.clone(),
            attack: self.attack.clone(),
            defense: self.defense.clone(),
            dropped_gold: self.dropped_gold.clone(),
            dropped_xp: self.dropped_xp.clone(),
            quality,
            loot: self.loot.clone(),
        }
    }
}

impl RegistryDefaults<MobId> for MobSpec {
    fn defaults() -> impl IntoIterator<Item = (MobId, Self)> {
        MobId::ALL.iter().map(|id| (*id, id.spec().clone()))
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Spawning
// ─────────────────────────────────────────────────────────────────────────────

/// Builder for spawning modified mobs.
pub struct MobSpawner {
    id: MobId,
    spec: MobSpec,
}

impl MobSpawner {
    /// Spawn the mob with all modifications applied.
    pub fn spawn(self) -> Mob {
        self.spec.spawn(self.id)
    }

    /// Scale all stat ranges by a multiplier.
    pub fn with_multiplier(mut self, multiplier: f32) -> Self {
        self.spec = self.spec.with_multiplier(multiplier);
        self
    }

    /// Change the mob's display name.
    pub fn with_name(mut self, name: impl Into<String>) -> Self {
        self.spec = self.spec.with_name(name);
        self
    }

    /// Set the mob's quality.
    pub fn with_quality(mut self, quality: MobQuality) -> Self {
        self.spec = self.spec.with_quality(quality);
        self
    }
}

impl MobId {
    /// Spawn a Mob instance from this MobId.
    pub fn spawn(&self) -> Mob {
        self.spec().spawn(*self)
    }

    /// Scale all stat ranges by a multiplier.
    pub fn with_multiplier(&self, multiplier: f32) -> MobSpawner {
        MobSpawner {
            id: *self,
            spec: self.spec().with_multiplier(multiplier),
        }
    }

    /// Change the mob's display name.
    pub fn with_name(&self, name: impl Into<String>) -> MobSpawner {
        MobSpawner {
            id: *self,
            spec: self.spec().with_name(name),
        }
    }

    /// Set the mob's quality.
    pub fn with_quality(&self, quality: MobQuality) -> MobSpawner {
        MobSpawner {
            id: *self,
            spec: self.spec().with_quality(quality),
        }
    }
}
