//! Mob definitions using the entity_macros system
//!
//! This file consolidates:
//! - MobSpec struct definition
//! - MobId enum
//! - All mob spec constants
//! - The spec() method on MobId

use std::ops::RangeInclusive;
use std::collections::HashMap;

use rand::Rng;

use crate::item::ItemId;
use crate::loot::LootTable;
use crate::registry::{Registry, RegistryDefaults, SpawnFromSpec};
use crate::stats::{StatInstance, StatSheet, StatType};

use super::definition::Mob;

// MobQuality is kept separate since it's a simple enum not generated by macro
pub use super::enums::MobQuality;

entity_macros::define_entity! {
    spec MobSpec {
        pub name: &'static str,
        pub max_health: RangeInclusive<i32>,
        pub attack: RangeInclusive<i32>,
        pub defense: RangeInclusive<i32>,
        pub dropped_gold: RangeInclusive<i32>,
        pub dropped_xp: RangeInclusive<i32>,
        pub quality: MobQuality,
        pub loot: LootTable,
    }

    id MobId;

    variants {
        Slime {
            name: "Slime",
            quality: MobQuality::Normal,
            max_health: 15..=22,
            attack: 2..=4,
            defense: 1..=3,
            dropped_gold: 1..=3,
            dropped_xp: 5..=9,
            loot: LootTable::new()
                .with(ItemId::SlimeGel, 3, 4, 1..=4)
                .with(ItemId::GoldRing, 1, 100, 1..=1),
        }
        Cow {
            name: "Cow",
            quality: MobQuality::Normal,
            max_health: 20..=25,
            attack: 1..=4,
            defense: 0..=2,
            dropped_gold: 1..=3,
            dropped_xp: 5..=9,
            loot: LootTable::new()
                .with(ItemId::Cowhide, 3, 4, 1..=3)
                .with(ItemId::GoldRing, 1, 1000, 1..=1),
        }
        Goblin {
            name: "Goblin",
            quality: MobQuality::Normal,
            max_health: 33..=41,
            attack: 10..=15,
            defense: 5..=10,
            dropped_gold: 10..=19,
            dropped_xp: 13..=20,
            loot: LootTable::new()
                .with(ItemId::Sword, 1, 15, 1..=1)
                .with(ItemId::BasicShield, 1, 15, 1..=1)
                .with(ItemId::GoldRing, 1, 100, 1..=1),
        }
        Dragon {
            name: "Dragon",
            quality: MobQuality::Boss,
            max_health: 500..=700,
            attack: 50..=70,
            defense: 30..=50,
            dropped_gold: 250..=350,
            dropped_xp: 500..=750,
            loot: LootTable::new()
                .with(ItemId::GoldRing, 1, 100, 1..=1)
                .with(ItemId::QualityUpgradeStone, 1, 1, 1..=1),
        }
    }
}

// Re-export MobRegistry type for compatibility
pub type MobRegistry = Registry<MobId, MobSpec>;

// ─────────────────────────────────────────────────────────────────────────────
// Spawn Implementation
// ─────────────────────────────────────────────────────────────────────────────

impl SpawnFromSpec<MobId> for MobSpec {
    type Output = Mob;

    fn spawn_from_spec(kind: MobId, spec: &Self) -> Self::Output {
        let mut rng = rand::thread_rng();
        let hp_min = spec.max_health.start();
        let hp_max = spec.max_health.end();
        let hp_median = (hp_min + hp_max) as f32 / 2.0;
        let attack = rng.gen_range(spec.attack.clone());
        let defense = rng.gen_range(spec.defense.clone());
        let base_gold = rng.gen_range(spec.dropped_gold.clone());
        let max_hp = rng.gen_range(spec.max_health.clone());
        let hp = max_hp as f32;

        let excess_ratio = if hp > hp_median {
            (hp - hp_median) / (*hp_max as f32 - hp_median)
        } else {
            0.0
        };
        let base_xp = rng.gen_range(spec.dropped_xp.clone());
        let bonus_multiplier = 1.0 + excess_ratio * 0.5;
        let dropped_xp = (base_xp as f32 * bonus_multiplier).round() as i32;
        let gold = (base_gold as f32 * bonus_multiplier).round() as i32;

        Mob {
            spec: kind,
            name: spec.name,
            quality: spec.quality.clone(),
            gold,
            stats: {
                let stats: HashMap<StatType, StatInstance> = HashMap::new();
                let mut sheet = StatSheet { stats };
                sheet.insert(StatType::Attack.instance(attack));
                sheet.insert(StatType::Defense.instance(defense));
                sheet.insert(StatType::Health.instance(max_hp));
                sheet
            },
            loot_table: spec.loot.clone(),
            dropped_xp,
            death_processed: false,
        }
    }
}

impl RegistryDefaults<MobId> for MobSpec {
    fn defaults() -> impl IntoIterator<Item = (MobId, Self)> {
        MobId::ALL.iter().map(|id| (*id, id.spec().clone()))
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Convenience Methods
// ─────────────────────────────────────────────────────────────────────────────

impl MobId {
    /// Spawn a Mob instance from this MobId
    pub fn spawn(&self) -> Mob {
        MobSpec::spawn_from_spec(*self, self.spec())
    }
}
